// Generated by CoffeeScript 1.8.0

/*
          >>>
          >>>                        >>>                         >>>
     >>>>>>>>   >>>>>>>    >>>>>>>   >>>>>   >>>>>>>    >>>>>>   >>>>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>   >>>  >>>       >>>
    >>>   >>>  >>>   >>>  >>>        >>>    >>>>>>>>>  >>>>>>>>  >>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>             >>>  >>>
     >>>>>>>>   >>>>>>>    >>>>>>>    >>>>   >>>>>>>    >>>>>>    >>>>
    .....................x.......xx.x.................................
 */

(function() {
  var CoffeeScript, R, commonjsEval, doctest, esprima, fetch, fs, functionEval, log, noop, pathlib, reduce, repr, rewrite, run, substring, toModule, toPairs, transformComments, wrap, _;

  doctest = function(path, options, callback) {
    var type, validateOption, _ref;
    if (options == null) {
      options = {};
    }
    if (callback == null) {
      callback = noop;
    }
    validateOption = function(name, validValues) {
      if (name in options && !R.contains(options[name], validValues)) {
        throw new Error("Invalid " + name + " `" + options[name] + "'");
      }
    };
    validateOption('module', ['amd', 'commonjs']);
    validateOption('type', ['coffee', 'js']);
    type = (_ref = options.type) != null ? _ref : (function() {
      var match;
      match = R.match(/[.](coffee|js)$/, path);
      if (match === null) {
        throw new Error('Cannot infer type from extension');
      }
      return match[1];
    })();
    return fetch(path, options, function(text) {
      var results, source;
      source = toModule(rewrite(text, type), options.module);
      if (options.print) {
        if (!options.silent) {
          console.log(R.replace(/\n$/, '', source));
        }
        callback(source);
        return source;
      } else {
        results = options.module === 'commonjs' ? commonjsEval(source, path) : functionEval(source);
        if (!options.silent) {
          log(results);
        }
        callback(results);
        return results;
      }
    });
  };

  doctest.version = '0.7.1';

  if (typeof window !== 'undefined') {
    _ = window._, CoffeeScript = window.CoffeeScript, esprima = window.esprima, R = window.R;
    window.doctest = doctest;
  } else {
    fs = require('fs');
    pathlib = require('path');
    _ = require('underscore');
    CoffeeScript = require('coffee-script');
    esprima = require('esprima');
    R = require('ramda');
    module.exports = doctest;
  }

  noop = function() {};

  reduce = R.flip(R.reduce);

  toPairs = R.converge(R.zip, R.pipe(R.length, R.range(0)), R.identity);

  fetch = function(path, options, callback) {
    var silent, wrapper;
    silent = options.silent || options.print;
    wrapper = function(text) {
      var name;
      name = R.last(R.split('/', path));
      if (!silent) {
        console.log("running doctests in " + name + "...");
      }
      return callback(text);
    };
    if (!silent) {
      console.log("retrieving " + path + "...");
    }
    if (typeof window !== 'undefined') {
      return jQuery.ajax(path, {
        dataType: 'text',
        success: wrapper
      });
    } else {
      return wrapper(fs.readFileSync(path, 'utf8'));
    }
  };

  rewrite = function(input, type) {
    return rewrite[type](input.replace(/\r\n?/g, '\n').replace(/^#!.*/, ''));
  };

  toModule = function(source, moduleType) {
    switch (moduleType) {
      case 'amd':
        return "" + source + "\nfunction define() {\n  for (var idx = 0; idx < arguments.length; idx += 1) {\n    if (typeof arguments[idx] == 'function') {\n      arguments[idx]();\n      break;\n    }\n  }\n}";
      case 'commonjs':
        return "var __doctest = {\n  queue: [],\n  input: function(fn) {\n    __doctest.queue.push([fn]);\n  },\n  output: function(num, fn) {\n    __doctest.queue.push([fn, num]);\n  }\n};\n\n" + source + "\n(module.exports || exports).__doctest = __doctest;";
      default:
        return source;
    }
  };

  transformComments = R.pipe(toPairs, reduce(['default', []], function(_arg, _arg1) {
    var accum, comment, commentIndex, state;
    state = _arg[0], accum = _arg[1];
    commentIndex = _arg1[0], comment = _arg1[1];
    return R.pipe(R.prop('value'), R.split('\n'), toPairs, reduce([state, accum], function(_arg2, _arg3) {
      var accum, end, idx, line, normalizedLine, prefix, start, state, value, _ref, _ref1;
      state = _arg2[0], accum = _arg2[1];
      idx = _arg3[0], line = _arg3[1];
      switch (comment.type) {
        case 'Block':
          normalizedLine = R.replace(/^\s*[*]?\s*/, '', line);
          start = end = {
            line: comment.loc.start.line + idx
          };
          break;
        case 'Line':
          normalizedLine = R.replace(/^\s*/, '', line);
          _ref = comment.loc, start = _ref.start, end = _ref.end;
      }
      _ref1 = R.tail(R.match(/^(>|[.]*)[ ]?(.*)$/, normalizedLine)), prefix = _ref1[0], value = _ref1[1];
      if (prefix === '>') {
        return [
          'input', R.appendTo(accum, {
            commentIndex: commentIndex,
            input: {
              loc: {
                start: start,
                end: end
              },
              value: value
            }
          })
        ];
      } else if (state === 'default') {
        return ['default', accum];
      } else if (state === 'input') {
        if (prefix) {
          return [
            'input', R.appendTo(R.slice(0, -1, accum), {
              commentIndex: commentIndex,
              input: {
                loc: {
                  start: R.last(accum).input.loc.start,
                  end: end
                },
                value: "" + (R.last(accum).input.value) + "\n" + value
              }
            })
          ];
        } else {
          return [
            'output', R.appendTo(R.slice(0, -1, accum), {
              commentIndex: commentIndex,
              input: R.last(accum).input,
              output: {
                loc: {
                  start: start,
                  end: end
                },
                value: value
              }
            })
          ];
        }
      } else if (state === 'output') {
        if (prefix) {
          return [
            'output', R.appendTo(R.slice(0, -1, accum), {
              commentIndex: commentIndex,
              input: R.last(accum).input,
              output: {
                loc: {
                  start: R.last(accum).output.loc.start,
                  end: end
                },
                value: "" + (R.last(accum).output.value) + "\n" + value
              }
            })
          ];
        } else {
          return ['default', accum];
        }
      }
    }))(comment);
  }), R.last);

  substring = function(input, start, end) {
    if (start.line === end.line && start.column === end.column) {
      return '';
    }
    return R.pipe(R.split(/^/m), toPairs, reduce(['', false], function(accum, _arg) {
      var idx, isEndLine, isStartLine, line;
      idx = _arg[0], line = _arg[1];
      isStartLine = idx + 1 === start.line;
      isEndLine = idx + 1 === end.line;
      return R.pipe(R.split(''), toPairs, reduce(['', R.last(accum)], function(_arg1, _arg2) {
        var chr, chrs, column, inComment;
        chrs = _arg1[0], inComment = _arg1[1];
        column = _arg2[0], chr = _arg2[1];
        if ((isStartLine && column === start.column) || inComment && !(isEndLine && column === end.column)) {
          return [R.concat(chrs, chr), true];
        } else {
          return [chrs, false];
        }
      }), R.converge(R.prepend, R.pipe(R.head, R.concat(R.head(accum))), R.tail))(line);
    }), R.head)(input);
  };

  wrap = R.curry(function(type, test) {
    return R.pipe(R.filter(R.rPartial(R.has, test)), R.map(function(dir) {
      return wrap[type][dir](test);
    }), R.join('\n'))(['input', 'output']);
  });

  wrap.js = wrap('js');

  wrap.js.input = function(test) {
    return "__doctest.input(function() {\n  return " + test.input.value + ";\n});";
  };

  wrap.js.output = function(test) {
    return "__doctest.output(" + test.output.loc.start.line + ", function() {\n  return " + test.output.value + ";\n});";
  };

  wrap.coffee = wrap('coffee');

  wrap.coffee.input = function(test) {
    return "__doctest.input ->\n" + (R.replace(/^/gm, '  ', test.input.value));
  };

  wrap.coffee.output = function(test) {
    return "__doctest.output " + test.output.loc.start.line + ", ->\n" + (R.replace(/^/gm, '  ', test.output.value));
  };

  rewrite.js = function(input) {
    var blockTests, bookend, getComments, lineTests, source, _ref;
    bookend = {
      value: '',
      loc: {
        start: {
          line: Infinity,
          column: Infinity
        }
      }
    };
    getComments = R.pipe(R.rPartial(esprima.parse, {
      comment: true,
      loc: true
    }), R.prop('comments'));
    _ref = R.pipe(getComments, R.partition(R.propEq('type', 'Block')), R.map(transformComments))(input), blockTests = _ref[0], lineTests = _ref[1];
    source = R.pipe(R.append({
      input: bookend
    }), reduce([
      [], {
        line: 1,
        column: 0
      }
    ], function(_arg, test) {
      var chunks, start, _ref1;
      chunks = _arg[0], start = _arg[1];
      return [R.appendTo(chunks, substring(input, start, test.input.loc.start)), ((_ref1 = test.output) != null ? _ref1 : test.input).loc.end];
    }), R.head, R.rPartial(R.zip, R.append('', R.map(wrap.js, lineTests))), R.flatten, R.join(''))(lineTests);
    return R.pipe(getComments, R.filter(R.propEq('type', 'Block')), R.append(bookend), toPairs, reduce([
      [], {
        line: 1,
        column: 0
      }
    ], function(_arg, _arg1) {
      var chunks, comment, idx, start;
      chunks = _arg[0], start = _arg[1];
      idx = _arg1[0], comment = _arg1[1];
      return R.pipe(R.filter(R.propEq('commentIndex', idx)), R.map(wrap.js), R.join('\n'), R.appendTo(R.append(substring(source, start, comment.loc.start), chunks)), R.of, R.append(comment.loc.end))(blockTests);
    }), R.head, R.join(''))(source);
  };

  rewrite.coffee = function(input) {
    var commentChunks, literalChunks, matchLine, testChunks, _ref;
    _ref = R.pipe(R.match(/.*\n/g), toPairs, R.reduce(function(_arg, _arg1) {
      var commentChunks, current, idx, inCommentChunk, isComment, line, literalChunks;
      literalChunks = _arg[0], commentChunks = _arg[1], inCommentChunk = _arg[2];
      idx = _arg1[0], line = _arg1[1];
      isComment = /^[ \t]*#(?!##)/.test(line);
      current = isComment ? commentChunks : literalChunks;
      if (isComment === inCommentChunk) {
        current[current.length - 1].value += line;
      } else {
        current[current.length] = {
          value: line,
          loc: {
            start: {
              line: idx + 1
            }
          }
        };
      }
      return [literalChunks, commentChunks, isComment];
    }, [
      [
        {
          value: '',
          loc: {
            start: {
              line: 1
            }
          }
        }
      ], [], false
    ]))(input), literalChunks = _ref[0], commentChunks = _ref[1];
    matchLine = R.match(/^([ \t]*)#[ \t]*(>|[.]*)(.*\n)/);
    testChunks = R.map(R.pipe(function(commentChunk) {
      return R.pipe(R.prop('value'), R.match(/.*\n/g), toPairs, reduce(['default', []], function(_arg, _arg1) {
        var idx, indent, line, loc, prefix, state, tests, value, _ref1;
        state = _arg[0], tests = _arg[1];
        idx = _arg1[0], line = _arg1[1];
        _ref1 = R.tail(matchLine(line)), indent = _ref1[0], prefix = _ref1[1], value = _ref1[2];
        if (prefix === '>') {
          tests[tests.length] = {
            indent: indent,
            input: {
              value: value
            }
          };
          return ['input', tests];
        } else if (prefix) {
          tests[tests.length - 1][state].value += value;
          return [state, tests];
        } else if (state === 'input') {
          loc = {
            start: {
              line: commentChunk.loc.start.line + idx
            }
          };
          tests[tests.length - 1].output = {
            loc: loc,
            value: value
          };
          return ['output', tests];
        } else {
          return ['default', tests];
        }
      }))(commentChunk);
    }, R.last, R.map(R.converge(R.replace(/^/gm), R.prop('indent'), wrap.coffee)), R.join('\n')), commentChunks);
    return R.pipe(R.zip, R.flatten, R.join('\n'), CoffeeScript.compile)(R.pluck('value', literalChunks), R.append('', testChunks));
  };

  functionEval = function(source) {
    var evaluate, queue;
    evaluate = Function('__doctest', source);
    queue = [];
    evaluate({
      input: function(fn) {
        return queue.push([fn]);
      },
      output: function(num, fn) {
        return queue.push([fn, num]);
      }
    });
    return run(queue);
  };

  commonjsEval = function(source, path) {
    var abspath, queue;
    abspath = pathlib.resolve(path).replace(/[.][^.]+$/, "-" + (_.now()) + ".js");
    fs.writeFileSync(abspath, source);
    try {
      queue = require(abspath).__doctest.queue;
    } finally {
      fs.unlinkSync(abspath);
    }
    return run(queue);
  };

  run = function(queue) {
    var actual, arr, error, expected, input, results, _i, _len;
    results = [];
    input = noop;
    for (_i = 0, _len = queue.length; _i < _len; _i++) {
      arr = queue[_i];
      switch (arr.length) {
        case 1:
          input();
          input = arr[0];
          break;
        case 2:
          actual = (function() {
            try {
              return input();
            } catch (_error) {
              error = _error;
              return error.constructor;
            }
          })();
          expected = arr[0]();
          results.push([_.isEqual(actual, expected), repr(expected), repr(actual), arr[1]]);
          input = noop;
      }
    }
    return results;
  };

  log = function(results) {
    var actual, expected, num, pass, _i, _len, _ref;
    console.log(R.join('', (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        pass = results[_i][0];
        _results.push(pass ? '.' : 'x');
      }
      return _results;
    })()));
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      _ref = results[_i], pass = _ref[0], expected = _ref[1], actual = _ref[2], num = _ref[3];
      if (!pass) {
        console.log("FAIL: expected " + expected + " on line " + num + " (got " + actual + ")");
      }
    }
  };

  repr = function(val) {
    switch (Object.prototype.toString.call(val)) {
      case '[object String]':
        return '"' + val.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
      case '[object Function]':
        return val.name;
      default:
        return val;
    }
  };

}).call(this);
