// Generated by CoffeeScript 1.7.1

/*
          >>>
          >>>                        >>>                         >>>
     >>>>>>>>   >>>>>>>    >>>>>>>   >>>>>   >>>>>>>    >>>>>>   >>>>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>   >>>  >>>       >>>
    >>>   >>>  >>>   >>>  >>>        >>>    >>>>>>>>>  >>>>>>>>  >>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>             >>>  >>>
     >>>>>>>>   >>>>>>>    >>>>>>>    >>>>   >>>>>>>    >>>>>>    >>>>
    .....................x.......xx.x.................................
 */

(function() {
  var CoffeeScript, commonjsEval, defineFunctionString, doctest, esprima, fetch, fs, functionEval, log, noop, pathlib, repr, rewrite, run, substring, transformComments, validators, _,
    __slice = [].slice;

  doctest = function(path, options, callback) {
    var type;
    if (options == null) {
      options = {};
    }
    if (callback == null) {
      callback = noop;
    }
    _.each(_.keys(validators).sort(), function(key) {
      if (!validators[key](options[key])) {
        throw new Error("Invalid " + key + " `" + options[key] + "'");
      }
    });
    type = options.type || (function() {
      var match;
      match = /[.](coffee|js)$/.exec(path);
      if (match === null) {
        throw new Error('Cannot infer type from extension');
      }
      return match[1];
    })();
    return fetch(path, options, function(text) {
      var results, source;
      source = rewrite[type](text.replace(/^#!.*/, ''));
      results = (function() {
        switch (options.module) {
          case 'amd':
            return functionEval("" + source + ";\n" + defineFunctionString);
          case 'commonjs':
            return commonjsEval(source, path);
          default:
            return functionEval(source);
        }
      })();
      if (!options.silent) {
        log(results);
      }
      callback(results);
      return results;
    });
  };

  doctest.version = '0.6.1';

  if (typeof window !== 'undefined') {
    _ = window._, CoffeeScript = window.CoffeeScript, esprima = window.esprima;
    window.doctest = doctest;
  } else {
    fs = require('fs');
    pathlib = require('path');
    _ = require('underscore');
    CoffeeScript = require('coffee-script');
    esprima = require('esprima');
    module.exports = doctest;
  }

  validators = {
    module: _.partial(_.contains, [void 0, 'amd', 'commonjs']),
    silent: _.constant(true),
    type: _.partial(_.contains, [void 0, 'coffee', 'js'])
  };

  fetch = function(path, options, callback) {
    var wrapper;
    wrapper = function(text) {
      var name;
      name = _.last(path.split('/'));
      if (!options.silent) {
        console.log("running doctests in " + name + "...");
      }
      return callback(text);
    };
    if (!options.silent) {
      console.log("retrieving " + path + "...");
    }
    if (typeof window !== 'undefined') {
      return jQuery.ajax(path, {
        dataType: 'text',
        success: wrapper
      });
    } else {
      return wrapper(fs.readFileSync(path, 'utf8'));
    }
  };

  rewrite = function(input, type) {
    return rewrite[type](input.replace(/\r\n?/g, '\n'));
  };

  transformComments = function(comments) {
    return _.last(_.reduce(comments, function(_arg, comment, commentIndex) {
      var accum, state;
      state = _arg[0], accum = _arg[1];
      return _.reduce(comment.value.split('\n'), function(_arg1, line, idx) {
        var accum, end, normalizedLine, prefix, start, state, value, _i, _ref, _ref1;
        state = _arg1[0], accum = _arg1[1];
        switch (comment.type) {
          case 'Block':
            normalizedLine = line.replace(/^\s*[*]?\s*/, '');
            start = end = {
              line: comment.loc.start.line + idx
            };
            break;
          case 'Line':
            normalizedLine = line.replace(/^\s*/, '');
            _ref = comment.loc, start = _ref.start, end = _ref.end;
        }
        _ref1 = /^(>|[.]*)(.*)$/.exec(normalizedLine), _i = _ref1.length - 2, prefix = _ref1[_i++], value = _ref1[_i++];
        if (prefix === '>') {
          return [
            1, accum.concat({
              commentIndex: commentIndex,
              input: {
                loc: {
                  start: start,
                  end: end
                },
                value: value
              }
            })
          ];
        } else if (state === 0) {
          return [0, accum];
        } else if (prefix) {
          return [
            1, _.initial(accum).concat({
              commentIndex: commentIndex,
              input: {
                loc: {
                  start: _.last(accum).input.loc.start,
                  end: end
                },
                value: "" + (_.last(accum).input.value) + "\n" + value
              }
            })
          ];
        } else {
          return [
            0, _.initial(accum).concat({
              commentIndex: commentIndex,
              input: _.last(accum).input,
              output: {
                loc: {
                  start: start,
                  end: end
                },
                value: value
              }
            })
          ];
        }
      }, [state, accum]);
    }, [0, []]));
  };

  substring = function(input, start, end) {
    var combine;
    if (start.line === end.line && start.column === end.column) {
      return '';
    }
    combine = function(a, b) {
      return ["" + a[0] + b[0], b[1]];
    };
    return _.first(_.reduce(input.split(/^/m), function(accum, line, idx) {
      var isEndLine, isStartLine;
      isStartLine = idx + 1 === start.line;
      isEndLine = idx + 1 === end.line;
      return combine(accum, _.reduce(line, function(_arg, chr, column) {
        var chrs, inComment;
        chrs = _arg[0], inComment = _arg[1];
        if ((isStartLine && column === start.column) || inComment && !(isEndLine && column === end.column)) {
          return ["" + chrs + chr, true];
        } else {
          return ["" + chrs, false];
        }
      }, ['', _.last(accum)]));
    }, ['', false]));
  };

  rewrite.js = function(input) {
    var blockTests, bookend, getComments, lineTests, source, wrap, _ref;
    wrap = function(test) {
      return _.chain(['input', 'output']).filter(_.partial(_.has, test)).map(function(type) {
        return wrap[type](test);
      }).value().join('\n');
    };
    wrap.input = function(test) {
      return "__doctest.input(function() {\n  return " + test.input.value + ";\n});";
    };
    wrap.output = function(test) {
      return "__doctest.output(" + test.output.loc.start.line + ", function() {\n  return " + test.output.value + ";\n});";
    };
    bookend = {
      value: '',
      loc: {
        start: {
          line: Infinity,
          column: Infinity
        }
      }
    };
    getComments = function(s) {
      return esprima.parse(s, {
        comment: true,
        loc: true
      }).comments;
    };
    _ref = _.chain(getComments(input)).partition(function(c) {
      return c.type === 'Block';
    }).map(transformComments).value(), blockTests = _ref[0], lineTests = _ref[1];
    source = _.chain(lineTests).concat({
      input: bookend
    }).reduce(function(_arg, test) {
      var chunks, start, _ref1;
      chunks = _arg[0], start = _arg[1];
      return [__slice.call(chunks).concat([substring(input, start, test.input.loc.start)]), ((_ref1 = test.output) != null ? _ref1 : test.input).loc.end];
    }, [
      [], {
        line: 1,
        column: 0
      }
    ]).first().zip(_.map(lineTests, wrap)).flatten().value().join('');
    return _.chain(getComments(source)).filter(function(c) {
      return c.type === 'Block';
    }).concat(bookend).reduce(function(_arg, comment, idx) {
      var chunks, s, start;
      chunks = _arg[0], start = _arg[1];
      s = _.chain(blockTests).filter(function(t) {
        return t.commentIndex === idx;
      }).map(wrap).value().join('\n');
      return [__slice.call(chunks).concat([substring(source, start, comment.loc.start)], [s]), comment.loc.end];
    }, [
      [], {
        line: 1,
        column: 0
      }
    ]).first().value().join('');
  };

  rewrite.coffee = function(input) {
    var source, wrap;
    wrap = {
      input: function(test) {
        return "__doctest.input -> " + test.input.value;
      },
      output: function(test) {
        return "__doctest.output " + test.output.loc.start.line + ", -> " + test.output.value;
      }
    };
    source = _.chain(input.split('\n')).reduce(function(_arg, line, idx) {
      var expr, indent, lines, match, prefix, value, _i;
      expr = _arg[0], lines = _arg[1];
      if (match = /^([ \t]*)#(?!##)[ \t]*(>|[.]*)(.*)$/.exec(line)) {
        _i = match.length - 3, indent = match[_i++], prefix = match[_i++], value = match[_i++];
        if (prefix === '>' && expr) {
          return [
            value, lines.concat("" + indent + (wrap.input({
              input: {
                value: expr
              }
            })))
          ];
        } else if (prefix === '>') {
          return [value, lines];
        } else if (prefix) {
          return ["" + expr + "\n" + indent + "  " + value, lines];
        } else if (expr) {
          return [
            '', lines.concat([
              "" + indent + (wrap.input({
                input: {
                  value: expr
                }
              })), "" + indent + (wrap.output({
                output: {
                  value: value,
                  loc: {
                    start: {
                      line: idx + 1
                    }
                  }
                }
              }))
            ])
          ];
        } else {
          return [expr, lines];
        }
      } else {
        return [expr, lines.concat(line)];
      }
    }, ['', []]).last().value().join('\n');
    return CoffeeScript.compile(source);
  };

  defineFunctionString = 'function define() {\n  var arg, idx;\n  for (idx = 0; idx < arguments.length; idx += 1) {\n    arg = arguments[idx];\n    if (typeof arg === \'function\') {\n      arg();\n      break;\n    }\n  }\n}';

  functionEval = function(source) {
    var evaluate, queue;
    evaluate = Function('__doctest', source);
    queue = [];
    evaluate({
      input: function(fn) {
        return queue.push([fn]);
      },
      output: function(num, fn) {
        return queue.push([fn, num]);
      }
    });
    return run(queue);
  };

  commonjsEval = function(source, path) {
    var abspath, queue;
    abspath = pathlib.resolve(path).replace(/[.][^.]+$/, "-" + (_.now()) + ".js");
    fs.writeFileSync(abspath, "var __doctest = {\n  queue: [],\n  input: function(fn) {\n    __doctest.queue.push([fn]);\n  },\n  output: function(num, fn) {\n    __doctest.queue.push([fn, num]);\n  }\n};\n" + source + "\n(module.exports || exports).__doctest = __doctest;");
    try {
      queue = require(abspath).__doctest.queue;
    } finally {
      fs.unlinkSync(abspath);
    }
    return run(queue);
  };

  run = function(queue) {
    var actual, arr, error, expected, input, results, _i, _len;
    results = [];
    input = noop;
    for (_i = 0, _len = queue.length; _i < _len; _i++) {
      arr = queue[_i];
      switch (arr.length) {
        case 1:
          input();
          input = arr[0];
          break;
        case 2:
          actual = (function() {
            try {
              return input();
            } catch (_error) {
              error = _error;
              return error.constructor;
            }
          })();
          expected = arr[0]();
          results.push([_.isEqual(actual, expected), repr(expected), repr(actual), arr[1]]);
          input = noop;
      }
    }
    return results;
  };

  log = function(results) {
    var actual, expected, num, pass, _i, _len, _ref;
    console.log(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        pass = results[_i][0];
        _results.push(pass ? '.' : 'x');
      }
      return _results;
    })()).join(''));
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      _ref = results[_i], pass = _ref[0], expected = _ref[1], actual = _ref[2], num = _ref[3];
      if (!pass) {
        console.log("FAIL: expected " + expected + " on line " + num + " (got " + actual + ")");
      }
    }
  };

  noop = function() {};

  repr = function(val) {
    switch (Object.prototype.toString.call(val)) {
      case '[object String]':
        return '"' + val.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
      case '[object Function]':
        return val.name;
      default:
        return val;
    }
  };

}).call(this);
