// Generated by CoffeeScript 1.7.1

/*
          >>>
          >>>                        >>>                         >>>
     >>>>>>>>   >>>>>>>    >>>>>>>   >>>>>   >>>>>>>    >>>>>>   >>>>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>   >>>  >>>       >>>
    >>>   >>>  >>>   >>>  >>>        >>>    >>>>>>>>>  >>>>>>>>  >>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>             >>>  >>>
     >>>>>>>>   >>>>>>>    >>>>>>>    >>>>   >>>>>>>    >>>>>>    >>>>
    .....................x.......xx.x.................................
 */

(function() {
  var CoffeeScript, R, commonjsEval, doctest, esprima, fetch, fs, functionEval, log, noop, pathlib, repr, rewrite, run, substring, toModule, transformComments, wrap, _,
    __slice = [].slice;

  doctest = function(path, options, callback) {
    var type, validateOption, _ref;
    if (options == null) {
      options = {};
    }
    if (callback == null) {
      callback = noop;
    }
    validateOption = function(name, validValues) {
      if (name in options && !R.contains(options[name], validValues)) {
        throw new Error("Invalid " + name + " `" + options[name] + "'");
      }
    };
    validateOption('module', ['amd', 'commonjs']);
    validateOption('type', ['coffee', 'js']);
    type = (_ref = options.type) != null ? _ref : (function() {
      var match;
      match = /[.](coffee|js)$/.exec(path);
      if (match === null) {
        throw new Error('Cannot infer type from extension');
      }
      return match[1];
    })();
    return fetch(path, options, function(text) {
      var results, source;
      source = toModule(rewrite(text, type), options.module);
      if (options.print) {
        if (!options.silent) {
          console.log(source.replace(/\n$/, ''));
        }
        callback(source);
        return source;
      } else {
        results = options.module === 'commonjs' ? commonjsEval(source, path) : functionEval(source);
        if (!options.silent) {
          log(results);
        }
        callback(results);
        return results;
      }
    });
  };

  doctest.version = '0.7.0';

  if (typeof window !== 'undefined') {
    _ = window._, CoffeeScript = window.CoffeeScript, esprima = window.esprima, R = window.ramda;
    window.doctest = doctest;
  } else {
    fs = require('fs');
    pathlib = require('path');
    _ = require('underscore');
    CoffeeScript = require('coffee-script');
    esprima = require('esprima');
    R = require('ramda');
    module.exports = doctest;
  }

  fetch = function(path, options, callback) {
    var silent, wrapper;
    silent = options.silent || options.print;
    wrapper = function(text) {
      var name;
      name = R.last(R.split('/', path));
      if (!silent) {
        console.log("running doctests in " + name + "...");
      }
      return callback(text);
    };
    if (!silent) {
      console.log("retrieving " + path + "...");
    }
    if (typeof window !== 'undefined') {
      return jQuery.ajax(path, {
        dataType: 'text',
        success: wrapper
      });
    } else {
      return wrapper(fs.readFileSync(path, 'utf8'));
    }
  };

  rewrite = function(input, type) {
    return rewrite[type](input.replace(/\r\n?/g, '\n').replace(/^#!.*/, ''));
  };

  toModule = function(source, moduleType) {
    switch (moduleType) {
      case 'amd':
        return "" + source + "\nfunction define() {\n  for (var idx = 0; idx < arguments.length; idx += 1) {\n    if (typeof arguments[idx] == 'function') {\n      arguments[idx]();\n      break;\n    }\n  }\n}";
      case 'commonjs':
        return "var __doctest = {\n  queue: [],\n  input: function(fn) {\n    __doctest.queue.push([fn]);\n  },\n  output: function(num, fn) {\n    __doctest.queue.push([fn, num]);\n  }\n};\n\n" + source + "\n(module.exports || exports).__doctest = __doctest;";
      default:
        return source;
    }
  };

  transformComments = R.pipe(R.reduce.idx(function(_arg, comment, commentIndex) {
    var accum, state;
    state = _arg[0], accum = _arg[1];
    return R.reduce.idx(function(_arg1, line, idx) {
      var accum, end, normalizedLine, prefix, start, state, value, _i, _ref, _ref1;
      state = _arg1[0], accum = _arg1[1];
      switch (comment.type) {
        case 'Block':
          normalizedLine = line.replace(/^\s*[*]?\s*/, '');
          start = end = {
            line: comment.loc.start.line + idx
          };
          break;
        case 'Line':
          normalizedLine = line.replace(/^\s*/, '');
          _ref = comment.loc, start = _ref.start, end = _ref.end;
      }
      _ref1 = /^(>|[.]*)[ ]?(.*)$/.exec(normalizedLine), _i = _ref1.length - 2, prefix = _ref1[_i++], value = _ref1[_i++];
      if (prefix === '>') {
        return [
          'input', accum.concat({
            commentIndex: commentIndex,
            input: {
              loc: {
                start: start,
                end: end
              },
              value: value
            }
          })
        ];
      } else if (state === 'default') {
        return ['default', accum];
      } else if (state === 'input') {
        if (prefix) {
          return [
            'input', R.slice(0, -1, accum).concat({
              commentIndex: commentIndex,
              input: {
                loc: {
                  start: R.last(accum).input.loc.start,
                  end: end
                },
                value: "" + (R.last(accum).input.value) + "\n" + value
              }
            })
          ];
        } else {
          return [
            'output', R.slice(0, -1, accum).concat({
              commentIndex: commentIndex,
              input: R.last(accum).input,
              output: {
                loc: {
                  start: start,
                  end: end
                },
                value: value
              }
            })
          ];
        }
      } else if (state === 'output') {
        if (prefix) {
          return [
            'output', R.slice(0, -1, accum).concat({
              commentIndex: commentIndex,
              input: R.last(accum).input,
              output: {
                loc: {
                  start: R.last(accum).output.loc.start,
                  end: end
                },
                value: "" + (R.last(accum).output.value) + "\n" + value
              }
            })
          ];
        } else {
          return ['default', accum];
        }
      }
    }, [state, accum], comment.value.split('\n'));
  }, ['default', []]), R.last);

  substring = function(input, start, end) {
    var combine;
    if (start.line === end.line && start.column === end.column) {
      return '';
    }
    combine = function(a, b) {
      return ["" + a[0] + b[0], b[1]];
    };
    return R.pipe(R.split(/^/m), R.reduce.idx(function(accum, line, idx) {
      var isEndLine, isStartLine;
      isStartLine = idx + 1 === start.line;
      isEndLine = idx + 1 === end.line;
      return combine(accum, R.reduce.idx(function(_arg, chr, column) {
        var chrs, inComment;
        chrs = _arg[0], inComment = _arg[1];
        if ((isStartLine && column === start.column) || inComment && !(isEndLine && column === end.column)) {
          return ["" + chrs + chr, true];
        } else {
          return ["" + chrs, false];
        }
      }, ['', R.last(accum)], line));
    }, ['', false]), R.first)(input);
  };

  wrap = function(type, test) {
    return R.pipe(R.filter(function(dir) {
      return Object.prototype.hasOwnProperty.call(test, dir);
    }), R.map(function(dir) {
      return wrap[type][dir](test);
    }), R.join('\n'))(['input', 'output']);
  };

  wrap.js = R.lPartial(wrap, 'js');

  wrap.js.input = function(test) {
    return "__doctest.input(function() {\n  return " + test.input.value + ";\n});";
  };

  wrap.js.output = function(test) {
    return "__doctest.output(" + test.output.loc.start.line + ", function() {\n  return " + test.output.value + ";\n});";
  };

  wrap.coffee = R.lPartial(wrap, 'coffee');

  wrap.coffee.input = function(test) {
    return "__doctest.input ->\n" + (test.input.value.replace(/^/gm, '  '));
  };

  wrap.coffee.output = function(test) {
    return "__doctest.output " + test.output.loc.start.line + ", ->\n" + (test.output.value.replace(/^/gm, '  '));
  };

  rewrite.js = function(input) {
    var blockTests, bookend, getComments, lineTests, source, _ref;
    bookend = {
      value: '',
      loc: {
        start: {
          line: Infinity,
          column: Infinity
        }
      }
    };
    getComments = R.pipe(R.rPartial(esprima.parse, {
      comment: true,
      loc: true
    }), R.prop('comments'));
    _ref = R.pipe(getComments, R.partition(R.pipe(R.prop('type'), R.eq('Block'))), R.map(transformComments))(input), blockTests = _ref[0], lineTests = _ref[1];
    source = R.pipe(R.concat, R.reduce(function(_arg, test) {
      var chunks, start, _ref1;
      chunks = _arg[0], start = _arg[1];
      return [__slice.call(chunks).concat([substring(input, start, test.input.loc.start)]), ((_ref1 = test.output) != null ? _ref1 : test.input).loc.end];
    }, [
      [], {
        line: 1,
        column: 0
      }
    ]), R.first, R.rPartial(R.zip, R.concat(R.map(wrap.js, lineTests), [''])), R.flatten, R.join(''))(lineTests, [
      {
        input: bookend
      }
    ]);
    return R.pipe(getComments, R.filter(R.pipe(R.prop('type'), R.eq('Block'))), R.rPartial(R.concat, [bookend]), R.reduce.idx(function(_arg, comment, idx) {
      var chunks, s, start;
      chunks = _arg[0], start = _arg[1];
      s = R.pipe(R.filter(R.pipe(R.prop('commentIndex'), R.eq(idx))), R.map(wrap.js), R.join('\n'))(blockTests);
      return [__slice.call(chunks).concat([substring(source, start, comment.loc.start)], [s]), comment.loc.end];
    }, [
      [], {
        line: 1,
        column: 0
      }
    ]), R.first, R.join(''))(source);
  };

  rewrite.coffee = function(input) {
    var commentChunks, literalChunks, testChunks, _ref;
    _ref = R.pipe(R.match(/.*\n/gm), R.reduce.idx(function(_arg, line, idx) {
      var commentChunks, current, inCommentChunk, isComment, literalChunks;
      literalChunks = _arg[0], commentChunks = _arg[1], inCommentChunk = _arg[2];
      isComment = /^[ \t]*#(?!##)/.test(line);
      current = isComment ? commentChunks : literalChunks;
      if (isComment === inCommentChunk) {
        current[current.length - 1].value += line;
      } else {
        current[current.length] = {
          value: line,
          loc: {
            start: {
              line: idx + 1
            }
          }
        };
      }
      return [literalChunks, commentChunks, isComment];
    }, [
      [
        {
          value: '',
          loc: {
            start: {
              line: 1
            }
          }
        }
      ], [], false
    ]))(input), literalChunks = _ref[0], commentChunks = _ref[1];
    testChunks = R.map(R.pipe(function(commentChunk) {
      return R.reduce.idx(function(_arg, line, idx) {
        var indent, loc, prefix, state, tests, value, _i, _ref1;
        state = _arg[0], tests = _arg[1];
        _ref1 = /^([ \t]*)#[ \t]*(>|[.]*)(.*\n)/.exec(line), _i = _ref1.length - 3, indent = _ref1[_i++], prefix = _ref1[_i++], value = _ref1[_i++];
        if (prefix === '>') {
          tests[tests.length] = {
            indent: indent,
            input: {
              value: value
            }
          };
          return ['input', tests];
        } else if (prefix) {
          tests[tests.length - 1][state].value += value;
          return [state, tests];
        } else if (state === 'input') {
          loc = {
            start: {
              line: commentChunk.loc.start.line + idx
            }
          };
          tests[tests.length - 1].output = {
            loc: loc,
            value: value
          };
          return ['output', tests];
        } else {
          return ['default', tests];
        }
      }, ['default', []], commentChunk.value.match(/.*\n/gm));
    }, R.last, R.map(function(test) {
      return wrap.coffee(test).replace(/^/gm, test.indent);
    }), R.join('\n')), commentChunks);
    return R.pipe(R.zip, R.flatten, R.join('\n'), CoffeeScript.compile)(R.pluck('value', literalChunks), R.concat(testChunks, ['']));
  };

  functionEval = function(source) {
    var evaluate, queue;
    evaluate = Function('__doctest', source);
    queue = [];
    evaluate({
      input: function(fn) {
        return queue.push([fn]);
      },
      output: function(num, fn) {
        return queue.push([fn, num]);
      }
    });
    return run(queue);
  };

  commonjsEval = function(source, path) {
    var abspath, queue;
    abspath = pathlib.resolve(path).replace(/[.][^.]+$/, "-" + (_.now()) + ".js");
    fs.writeFileSync(abspath, "var __doctest = {\n  queue: [],\n  input: function(fn) {\n    __doctest.queue.push([fn]);\n  },\n  output: function(num, fn) {\n    __doctest.queue.push([fn, num]);\n  }\n};\n" + source + "\n(module.exports || exports).__doctest = __doctest;");
    try {
      queue = require(abspath).__doctest.queue;
    } finally {
      fs.unlinkSync(abspath);
    }
    return run(queue);
  };

  run = function(queue) {
    var actual, arr, error, expected, input, results, _i, _len;
    results = [];
    input = noop;
    for (_i = 0, _len = queue.length; _i < _len; _i++) {
      arr = queue[_i];
      switch (arr.length) {
        case 1:
          input();
          input = arr[0];
          break;
        case 2:
          actual = (function() {
            try {
              return input();
            } catch (_error) {
              error = _error;
              return error.constructor;
            }
          })();
          expected = arr[0]();
          results.push([_.isEqual(actual, expected), repr(expected), repr(actual), arr[1]]);
          input = noop;
      }
    }
    return results;
  };

  log = function(results) {
    var actual, expected, num, pass, _i, _len, _ref;
    console.log(R.join('', (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        pass = results[_i][0];
        _results.push(pass ? '.' : 'x');
      }
      return _results;
    })()));
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      _ref = results[_i], pass = _ref[0], expected = _ref[1], actual = _ref[2], num = _ref[3];
      if (!pass) {
        console.log("FAIL: expected " + expected + " on line " + num + " (got " + actual + ")");
      }
    }
  };

  noop = function() {};

  repr = function(val) {
    switch (Object.prototype.toString.call(val)) {
      case '[object String]':
        return '"' + val.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
      case '[object Function]':
        return val.name;
      default:
        return val;
    }
  };

}).call(this);
